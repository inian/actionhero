<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Middleware | actionhero</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="../../assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="../../assets/js/search.js" data-base="../..">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="../../index.html" class="title">actionhero</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
			</ul>
			<h1> Middleware</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<p><img src="api-first-development.svg" alt=""></p>
				<a href="#overview" id="overview" style="color: inherit; text-decoration: none;">
					<h2>Overview</h2>
				</a>
				<p>There are 4 types of middleware in ActionHero:</p>
				<ul>
					<li><strong>Action</strong></li>
					<li><strong>Connection</strong></li>
					<li><strong>Chat</strong></li>
					<li><strong>Task</strong></li>
				</ul>
				<p>Each type of middleware is distinct from the others, and operates on distinct parts of a client&#39;s lifecycle. For a logical example, please inspect the following connection lifecycle:</p>
				<pre><code class="language-bash">&gt; Client **Connects**
<span class="hljs-comment"># connection middleware, \`create\` hook</span>

&gt; Client requests an **action**
<span class="hljs-comment"># action middleware, \`preProcessor\` hook</span>
<span class="hljs-comment"># action middleware, \`postProcessor\` hook</span>

&gt; Client **joins a room**
<span class="hljs-comment"># chat middleware, \`join\` hook</span>

&gt; Client **says a message** <span class="hljs-keyword">in</span> a room
<span class="hljs-comment"># chat middleware, \`say\` hook</span>
<span class="hljs-comment"># chat middleware, \`onSayReceive\` hook</span>

&gt; Client requests a **disconnect** (quit)
<span class="hljs-comment"># chat middleware, \`leave\` hook</span>
<span class="hljs-comment"># connection middleware, \`destroy\` hook</span>

&gt; Client executes a **task**
<span class="hljs-comment"># task middleware, \`preProcessor\` hook</span>
<span class="hljs-comment"># task middleware, \`postProcessor\` hook</span></code></pre>
				<a href="#action-middleware" id="action-middleware" style="color: inherit; text-decoration: none;">
					<h2>Action Middleware</h2>
				</a>
				<p><img src="connection_flow_actions.png" alt=""></p>
				<pre><code class="language-js"><span class="hljs-keyword">const</span> middleware = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"userId checker"</span>,
  <span class="hljs-attr">global</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">priority</span>: <span class="hljs-number">1000</span>,
  <span class="hljs-attr">preProcessor</span>: <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (!data.params.userId) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"All actions require a userId"</span>);
    }
  },
  <span class="hljs-attr">postProcessor</span>: <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (data.thing.stuff == <span class="hljs-literal">false</span>) {
      data.toRender = <span class="hljs-literal">false</span>;
    }
  }
};

api.actions.addMiddleware(middleware);</code></pre>
				<p>ActionHero provides hooks for you to execute custom code both before and after the execution of all or some actions. This is a great place to write authentication logic or custom loggers.</p>
				<p>Action middleware requires a <code>name</code> and at least one of <code>preProcessor</code> or <code>postProcessor</code>. Middleware can be <code>global</code>, or you can choose to apply each middleware to an action specifically via <code>action.middleware = []</code> in the action&#39;s definition. You supply a list of middleware names, like <code>action.middleware = [&#39;userId checker&#39;]</code> in the example above.</p>
				<p>Each processor is passed <code>data</code>. Just like within actions, you can modify the <code>data</code> object to add to <code>data.response</code> to create a response to the client. If an error is thrown, the action will not execute, and <code>data.response.error</code> will contain the error. If a <code>preProcessor</code> has an error, the action will never be called.</p>
				<p>The priority of a middleware orders it with all other middleware which might fire for an action. All global middleware happen before locally defined middleware on an action. Lower numbers happen first. If you do not provide a priority, the default from <code>api.config.general.defaultProcessorPriority</code> will be used.</p>
				<a href="#the-data-object" id="the-data-object" style="color: inherit; text-decoration: none;">
					<h3>The Data Object</h3>
				</a>
				<p><code>data</code> contains the same information as would be passed to an action:</p>
				<pre><code class="language-js">data = {
  <span class="hljs-attr">connection</span>: {},
  <span class="hljs-attr">action</span>: <span class="hljs-string">"randomNumber"</span>,
  <span class="hljs-attr">toRender</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">messageId</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">params</span>: { <span class="hljs-attr">action</span>: <span class="hljs-string">"randomNumber"</span>, <span class="hljs-attr">apiVersion</span>: <span class="hljs-number">1</span> },
  <span class="hljs-attr">actionStartTime</span>: <span class="hljs-number">1429531553417</span>,
  <span class="hljs-attr">actionTemplate</span>: {}, <span class="hljs-comment">// the actual object action definition</span>
  <span class="hljs-attr">response</span>: {},
  <span class="hljs-attr">session</span>: {}
};</code></pre>
				<p>If your middleware wants to pass information about the connection to the action, place that data withinin the <code>session</code> object. For example, you might have a middleware that sets <code>session.user</code> for use in your actions:</p>
				<pre><code class="language-ts"><span class="hljs-keyword">const</span> authenticatedUserMiddleware = {
  name: <span class="hljs-string">"authenticated-team-member"</span>,
  global: <span class="hljs-literal">false</span>,
  priority: <span class="hljs-number">1000</span>,
  preProcessor: <span class="hljs-keyword">async</span> data =&gt; {
    <span class="hljs-keyword">const</span> { Team, TeamMember } = api.models;
    <span class="hljs-keyword">const</span> sessionData = <span class="hljs-keyword">await</span> api.session.load(data.connection);
    <span class="hljs-keyword">if</span> (!sessionData) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Please log in to continue"</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (
      !data.params.csrfToken ||
      data.params.csrfToken !== sessionData.csrfToken
    ) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"CSRF error"</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">const</span> teamMember = <span class="hljs-keyword">await</span> TeamMember.findOne({
        where: { guid: sessionData.guid },
        include: Team
      });
      data.session = { data: sessionData, teamMember };
    }
  }
};

api.actions.addMiddleware(authenticatedUserMiddleware);</code></pre>
				<a href="#connection-middleware" id="connection-middleware" style="color: inherit; text-decoration: none;">
					<h2>Connection Middleware</h2>
				</a>
				<pre><code class="language-js"><span class="hljs-keyword">const</span> connectionMiddleware = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"connection middleware"</span>,
  <span class="hljs-attr">priority</span>: <span class="hljs-number">1000</span>,
  <span class="hljs-attr">create</span>: <span class="hljs-keyword">async</span> connection =&gt; {
    api.log(<span class="hljs-string">"connection joined"</span>);
  },
  <span class="hljs-attr">destroy</span>: <span class="hljs-keyword">async</span> connection =&gt; {
    api.log(<span class="hljs-string">"connection left"</span>);
  }
};

api.connections.addMiddleware(connectionMiddleware);</code></pre>
				<p>Like the action middleware above, you can also create middleware to react to the creation or destruction of all connections.</p>
				<p>Keep in mind that some connections persist (webSocket, socket) and some only exist for the duration of a single request (web). You will likely want to inspect <code>connection.type</code> in this middleware. Again, if you do not provide a priority, the default from <code>api.config.general.defaultMiddlewarePriority</code> will be used.</p>
				<p>Any modification made to the connection at this stage may happen either before or after an action, and may or may not persist to the connection depending on how the server is implemented.</p>
				<a href="#chat-middleware" id="chat-middleware" style="color: inherit; text-decoration: none;">
					<h2>Chat Middleware</h2>
				</a>
				<pre><code class="language-js"><span class="hljs-keyword">var</span> chatMiddleware = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'chat middleware'</span>,
  <span class="hljs-attr">priority</span>: <span class="hljs-number">1000</span>,
  <span class="hljs-attr">join</span>: <span class="hljs-function">(<span class="hljs-params">connection, room</span>) =&gt;</span> {
    <span class="hljs-comment">// announce all connections entering a room</span>
    <span class="hljs-keyword">await</span> api.chatRoom.broadcast({}, room, <span class="hljs-string">'I have joined the room: '</span> + connection.id)
  },
  <span class="hljs-attr">leave</span>: <span class="hljs-function">(<span class="hljs-params">connection, room</span>) =&gt;</span> {
    <span class="hljs-comment">// announce all connections leaving a room</span>
    <span class="hljs-keyword">await</span> api.chatRoom.broadcast({}, room, <span class="hljs-string">'I have left the room: '</span> + connection.id)
  },
  <span class="hljs-comment">/**
   * Will be executed once per client connection before delivering the message.
   */</span>
  <span class="hljs-attr">say</span>: <span class="hljs-function">(<span class="hljs-params">connection, room, messagePayload</span>) =&gt;</span> {
    <span class="hljs-comment">// do stuff</span>
    api.log(messagePayload)
    messagePayload.cool = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">return</span> messagePayload
  },
  <span class="hljs-comment">/**
   * Will be executed only once, when the message is sent to the server.
   */</span>
  <span class="hljs-attr">onSayReceive</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">connection, room, messagePayload</span>)</span>{
    <span class="hljs-comment">// do stuff</span>
    api.log(messagePayload)
    messagePayload.recievedAt = (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).getTime()
    <span class="hljs-keyword">return</span> messagePayload
  }
};

api.chatRoom.addMiddleware(chatMiddleware)</code></pre>
				<p>The last type of middleware is used to act when a connection joins, leaves, or communicates within a chat room. We have 4 types of middleware for each step: <code>say</code>, <code>onSayReceive</code>, <code>join</code>, and <code>leave</code>.</p>
				<p>Priority is optional in all cases, but can be used to order your middleware. If an error is returned thrown any of these methods, it will be returned to the client, and the action/verb/message will not be sent.</p>
				<p>More detail and nuance on chat middleware can be found in the <a href="tutorial-chat.html">chat tutorial</a></p>
				<a href="#chat-middleware-notes" id="chat-middleware-notes" style="color: inherit; text-decoration: none;">
					<h3>Chat Middleware Notes</h3>
				</a>
				<ul>
					<li>In the example above, I want to announce the member joining the room, but he has not yet been added to the room, as the join logic is still firing. If the connection itself were to make the broadcast, it would fail because the connection is not in the room. Instead, an empty <code>{}</code> connection is used to proxy the message coming from the &#39;server&#39;.</li>
					<li>Only the <code>sayCallbacks</code> return <code>messagePayload</code>. This allows you to modify the message being sent to your clients.<ul>
							<li><code>messagePayload</code> will be modified and and passed on to all middlewares inline, so you can append and modify it as you go</li>
						</ul>
					</li>
					<li>If you have a number of callbacks (<code>say</code>, <code>onSayReceive</code>, <code>join</code> or <code>leave</code>), the priority maters, and you can block subsequent methods from firing by throwing an error.</li>
					<li><code>sayCallbacks</code> are executed once per client connection. This makes it suitable for customizing the message based on the individual client.</li>
					<li><code>onSayReceiveCallbacks</code> are executed only once, when the message is sent to the server.</li>
				</ul>
				<pre><code class="language-js"><span class="hljs-comment">// in this example no one will be able to join any room, and the \`say\` middleware will never be invoked.</span>

api.chatRoom.addMiddleware({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'blocking chat middleware'</span>,
  <span class="hljs-attr">join</span>: <span class="hljs-function">(<span class="hljs-params">connection, room</span>) =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'blocked from joining the room'</span>)
  }),

  <span class="hljs-attr">say</span>: <span class="hljs-function">(<span class="hljs-params">connection, room, messagePayload</span>) =&gt;</span> {
    api.chatRoom.broadcast({}, room, <span class="hljs-string">'I have entered the room: '</span> + connection.id)
  },
});</code></pre>
				<p>If a <code>say</code> is blocked via an error thrown, the message will simply not be delivered to the client. If a <code>join</code> or <code>leave</code> is blocked, the verb or method used to invoke the call will be returned that error.</p>
				<a href="#task-request-flow" id="task-request-flow" style="color: inherit; text-decoration: none;">
					<h2>Task Request Flow</h2>
				</a>
				<p><img src="connection_flow_tasks.png" alt=""></p>
				<a href="#task-middleware" id="task-middleware" style="color: inherit; text-decoration: none;">
					<h2>Task Middleware</h2>
				</a>
				<p>Task middleware is implemented as a thin wrapper around Node Resque plugins and currently exposes the <code>beforePerform</code>, <code>afterPerform</code>, <code>beforeEnqueue</code>, and <code>afterEnqueue</code> functions of Resque. Each middleware requires a <code>name</code> and at least one <code>function</code>. In addition, a middleware can be global, in which case it also requires a <code>priority</code>.</p>
				<p>In the <code>preProcessor</code>, you can access the original task <code>params</code> through <code>this.args[0]</code>. In the <code>postProcessor</code>, you can access the task result at <code>this.worker.result</code>. In the <code>preEnqueue</code> and <code>postEnqueue</code> you can access the task <code>params</code> through <code>this.args[0]</code>. If you wish to prevent a task from being enqueued using the <code>preEnqueue</code> middleware you must explicitly set the <code>toRun</code> value to <code>false</code> in the callback. Because the task middleware is executed by Resque <code>this</code> is an instance of a Resque Worker and contains a number of other elements which may be useful in a middleware.</p>
				<a href="#task-middleware-example" id="task-middleware-example" style="color: inherit; text-decoration: none;">
					<h3>Task Middleware Example</h3>
				</a>
				<p>The following example is a simplistic implementation of a task execution timer middleware.</p>
				<pre><code class="language-js"><span class="hljs-keyword">const</span> {api, Initializer} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'actionhero'</span>)

<span class="hljs-built_in">module</span>.exports = <span class="hljs-keyword">new</span> Class extends Initializer {
  <span class="hljs-keyword">constructor</span> () {
    <span class="hljs-keyword">super</span>()
    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">'task middleware'</span>
  }

  <span class="hljs-attr">initialize</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> middleware = {
      <span class="hljs-attr">name</span>: <span class="hljs-string">'timer'</span>,
      <span class="hljs-attr">global</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">priority</span>: <span class="hljs-number">90</span>,
      <span class="hljs-attr">preProcessor</span>: <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">this</span>.worker
        worker.startTime = process.hrtime()
      },
      <span class="hljs-attr">postProcessor</span>: <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">this</span>.worker
        <span class="hljs-keyword">const</span> elapsed = process.hrtime(worker.startTime)
        <span class="hljs-keyword">const</span> seconds = elapsed[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">const</span> millis = elapsed[<span class="hljs-number">1</span>] / <span class="hljs-number">1000000</span>
        api.log(worker.job.class + <span class="hljs-string">' done in '</span> + seconds + <span class="hljs-string">' s and '</span> + millis + <span class="hljs-string">' ms.'</span>, <span class="hljs-string">'info'</span>)
      },
      <span class="hljs-attr">preEnqueue</span>: <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">const</span> arg = <span class="hljs-keyword">this</span>.args[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">return</span> (arg === <span class="hljs-string">'ok'</span>) <span class="hljs-comment">// returing `false` will prevent the task from enqueing</span>
      },
      <span class="hljs-attr">postEnqueue</span>: <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        api.log(<span class="hljs-string">"Task successfully enqueued!"</span>)
      }
    }

    api.tasks.addMiddleware(middleware)
  }
}</code></pre>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="../../globals.html"><em>Globals</em></a>
					</li>
					<li class="current ">
						<a href="../index.html">Tutorial index</a>
						<ul>
							<li class="current ">
								<a href="index.html">Actionhero <wbr>Core <wbr>Features</a>
								<ul>
									<li class=" ">
										<a href="actions.html">Actions</a>
									</li>
									<li class=" ">
										<a href="tasks.html">Tasks</a>
									</li>
									<li class=" ">
										<a href="initializers.html">Initializers</a>
									</li>
									<li class=" ">
										<a href="localization.html">Localization</a>
									</li>
									<li class="current ">
										<a href="middleware.html">Middleware</a>
									</li>
									<li class=" ">
										<a href="testing.html">Testing</a>
									</li>
									<li class=" ">
										<a href="chat.html">Chat</a>
									</li>
									<li class=" ">
										<a href="servers/index.html">Servers</a>
									</li>
									<li class=" ">
										<a href="cli.html">Cli</a>
									</li>
								</ul>
							</li>
							<li class=" ">
								<a href="../config-and-dev/index.html">Configuration and <wbr>Development</a>
							</li>
							<li class=" ">
								<a href="../advanced/index.html">Advanced <wbr>Actionhero <wbr>Topics</a>
							</li>
						</ul>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
				<li class="tsd-kind-type-alias tsd-has-type-parameter"><span class="tsd-kind-icon">Type alias with type parameter</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="../../assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="../../assets/js/search.js"><' + '/script>');</script>
</body>
</html>